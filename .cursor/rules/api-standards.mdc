---
description: API development standards and Express.js best practices
globs: ["apps/api/**/*.ts", "apps/api/**/*.js"]
alwaysApply: true
---

# API Development Standards

## Express.js Best Practices

- Use TypeScript for all API endpoints
- Implement proper error handling middleware
- Use Zod for request/response validation
- Use Morgan for HTTP request logging
- Implement CORS properly for cross-origin requests

## Database Operations

- Use the service layer for all transactions
- Implement proper transaction handling

## Authentication & Sessions

- Use express-session for session management
- Implement proper session store with Prisma
- Use secure session configuration
- Implement proper logout functionality

## API Structure

- Use RESTful conventions for endpoints
- Implement proper HTTP status codes
- Use consistent response formats
- Implement proper input validation
- Use middleware for cross-cutting concerns

## Express Router Organization

### Nested Routes Structure

- **Follow Express.js conventions** for nested routes
- **Use proper directory structure** that mirrors the URL structure
- **Create separate router files** for nested resources

### Directory Organization

```
apps/api/src/
├── router.ts                    # Main router
├── auth/
│   ├── middleware.ts
│   └── router.ts
├── servers/
│   ├── router.ts                # Server routes
│   └── raids/
│       └── router.ts            # Nested raids routes
└── shared/
    └── middleware.ts            # Shared middleware
```

### Router Implementation

- **Use `Router({ mergeParams: true })`** for nested routers to inherit parent parameters
- **Mount nested routers** using `parentRouter.use("/:parentId/child", childRouter)`
- **Keep related routes together** in the same directory
- **Use descriptive router names** (e.g., `serverRaidsRouter` for nested raids)

### Route Parameter Inheritance

- **Parent parameters** (like `:serverId`) are automatically available in nested routers
- **Access parameters** using `req.params.parentId` in nested routes
- **Maintain type safety** with proper TypeScript parameter types
- **Validate parameters** in middleware before reaching route handlers

### Examples

```typescript
// Main router
router.use("/servers", serverRouter);

// Server router
serverRouter.use("/:serverId/raids", serverRaidsRouter);

// Nested raids router (with mergeParams: true)
serverRaidsRouter.get("/", (req, res) => {
  const { serverId } = req.params; // Inherited from parent
  // Handle GET /servers/:serverId/raids
});
```

### Benefits

- **Clean separation** of concerns
- **Proper Express conventions** for maintainability
- **Type safety** throughout the route hierarchy
- **Easy to understand** URL structure
- **Scalable** for complex nested resources

## Error Handling

- Implement global error handling middleware
- Use proper HTTP status codes for different error types
- Log errors appropriately using the shared logger package
- Return consistent error response formats

## Security

- Validate all input data
- Implement proper CORS configuration
- Use environment variables for sensitive configuration
- Implement rate limiting where appropriate
- Sanitize user inputs

## Testing

- Write unit tests for business logic
- Test API endpoints with proper mocking
- Use integration tests for database operations
- Test error scenarios and edge cases

---

description: API development standards and Express.js best practices
globs: ["apps/api/**/*.ts", "apps/api/**/*.js"]
alwaysApply: true
