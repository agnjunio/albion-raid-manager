---
description: Testing standards and best practices for the Albion Raid Manager project
globs: ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.spec.tsx"]
alwaysApply: true
---

# Testing Standards

## Core Testing Principles

### Test Direct Functionality Only

**CRITICAL RULE: Never test dependencies or external services directly.**

- **Test your code's behavior**, not the behavior of libraries, frameworks, or external APIs
- **Mock all external dependencies** including databases, APIs, Discord.js, and third-party services
- **Focus on business logic** and user-facing functionality
- **Verify interactions** with dependencies through mocks, not actual calls

### What to Test

**✅ DO Test:**

- Business logic and algorithms
- Input validation and error handling
- State management and data transformations
- User interactions and command responses
- Edge cases and error conditions
- Integration between your modules (with mocked dependencies)

**❌ DON'T Test:**

- Discord.js internal functionality
- Database query execution (test the logic that builds queries)
- External API responses (mock them)
- Framework behavior (React, Express, etc.)
- Third-party library functionality

## Vitest Setup Guidelines

**Purpose**: Global mocking for dependencies used across multiple test files.

**✅ Mock in Vitest Setup:**

- External dependencies (databases, Redis, HTTP clients)
- Infrastructure services (logging, configuration, external APIs)
- Complex objects (Prisma client with nested structure)
- Utilities used everywhere (cache utilities, common helpers)

**❌ Don't Mock in Vitest Setup:**

- Business logic services (like `./servers`)
- Test-specific behavior that needs different behavior per test
- Local dependencies (relative imports within the same package)

**Best Practices:**

```typescript
// ✅ Use factory functions for complex objects
const createMockFn = () => vi.fn();
const createMockPrismaClient = () => ({
  $transaction: createMockFn(),
  build: { create: createMockFn(), findUnique: createMockFn(), /* ... */ },
});

// ✅ Make mocks transparent by default
vi.mock("@albion-raid-manager/core/cache/utils", () => ({
  withCache: vi.fn((fn) => fn()), // Just call the function directly
}));

// ✅ Group related mocks by domain
// Database and ORM
vi.mock("@albion-raid-manager/core/database", () => ({ ... }));
// External Services
vi.mock("axios", () => ({ ... }));
```

## Individual Test Mocking

**CRITICAL: Use explicit vi.mock calls in each test file for dependencies that need mocking**

**NEW PATTERN: Call vi.mock on every dependency that needs a mock in unit tests**

**IMPORTANT: Only mock implementations when strictly needed - don't mock everything by default**

### Mocking Strategies

**Use Automatic Mocking (vi.mock without second parameter):**

```typescript
// ✅ Good - Auto-mocks all exports of the module
vi.mock("@albion-raid-manager/core/database");
vi.mock("@albion-raid-manager/core/logger");
vi.mock("axios");
```

**Use Custom Mocking (vi.mock with implementation):**

```typescript
// ✅ Good - Custom behavior when needed
vi.mock("./servers", () => ({
  ServersService: {
    ensureServer: vi.fn().mockResolvedValue(mockServer),
  },
}));
```

### Integration with Vitest Setup

**Leverage Vitest Setup When Possible:**

```typescript
// test-file.test.ts
import { beforeEach, describe, expect, it, vi } from "vitest";

// Mock dependencies - use automatic mocking when possible
vi.mock("@albion-raid-manager/core/logger"); // Auto-mocks all exports
// Note: @albion-raid-manager/core/cache/utils is handled by vitest setup

// Custom mock only when we need specific behavior
vi.mock("./servers", () => ({
  ServersService: {
    ensureServer: vi.fn().mockResolvedValue(mockServer),
  },
}));

import { BuildService } from "./builds";
```

**Key Principles:**

1. **Don't Override Vitest Setup**: Avoid `vi.mock()` calls for modules already mocked in vitest setup
2. **Use Automatic Mocking**: Use `vi.mock("@module")` without implementation for simple cases
3. **Custom Mock When Needed**: Provide custom implementation for complex objects or specific behavior

### When to Mock

**✅ Mock:**

- External services (databases, APIs, Discord.js)
- Dependencies with side effects (file system, network calls)
- When testing error conditions (database failures, API errors)
- When you need to verify interactions (function calls, parameters)

**❌ Don't Mock:**

- Pure utility functions (math operations, string manipulation)
- Simple data transformations (object mapping, filtering)
- Constants or enums (unless from external packages)
- Internal business logic (unless testing integration)

## Test Structure

```typescript
describe("Feature Name", () => {
  let mockDependency: MockedFunction;

  beforeEach(() => {
    vi.clearAllMocks();
    mockDependency = vi.fn();
  });

  describe("Happy Path", () => {
    it("should handle valid input", async () => {
      // Arrange
      const input = "valid-input";
      mockDependency.mockResolvedValue(expectedResult);

      // Act
      const result = await functionUnderTest(input);

      // Assert
      expect(result).toEqual(expectedResult);
      expect(mockDependency).toHaveBeenCalledWith(input);
    });
  });

  describe("Error Handling", () => {
    it("should handle invalid input", async () => {
      // Test error conditions
    });
  });

  describe("Edge Cases", () => {
    it("should handle boundary conditions", async () => {
      // Test edge cases
    });
  });
});
```

## Test Helpers and Maintenance

**Global Test Helpers:**

```typescript
// vitest.setup.ts
import { createMockBuild, createMockRaid, createMockUser } from "./src/test-helpers";

// Make helpers globally available
global.createMockBuild = createMockBuild;
global.createMockRaid = createMockRaid;
global.createMockUser = createMockUser;

// Clear mocks between tests
beforeEach(() => {
  vi.clearAllMocks();
});
```

**Maintenance:**

- Update mocks when external APIs change
- Keep setup synchronized across test files
- Document complex mock behaviors

## Test Coverage Guidelines

### Minimum Coverage Requirements

- **Unit Tests**: 80%+ coverage for business logic
- **Integration Tests**: Cover critical user workflows
- **Error Handling**: Test all error conditions
- **Edge Cases**: Test boundary conditions

### Coverage Exclusions

- **Generated code** (Prisma client, TypeScript interfaces)
- **Configuration files** (unless they contain business logic)
- **Simple getters/setters** (unless they have validation)
- **External library wrappers** (test your usage, not the library)

## Best Practices Summary

1. **Mock Everything External**: Never test third-party libraries or services
2. **Test Behavior, Not Implementation**: Focus on what the code does, not how
3. **Use Descriptive Test Names**: Make it clear what each test validates
4. **Arrange-Act-Assert**: Structure tests clearly
5. **Test Edge Cases**: Include boundary conditions and error scenarios
6. **Keep Tests Fast**: Use mocks to avoid slow external calls
7. **Use Vitest Setup for Global Mocks**: Put commonly used mocks in vitest setup
8. **Leverage Automatic Mocking**: Use `vi.mock("@module")` for simple cases
9. **Custom Mock When Needed**: Provide specific implementations for complex objects
10. **Use Factory Functions**: Create reusable mock factories for complex objects
11. **Maintain Test Data**: Use factories and builders for consistent data
12. **Reset Between Tests**: Clear mocks in beforeEach for test isolation

---

**Remember**: The goal is to test YOUR code's behavior, not the behavior of external dependencies. Mock everything external and focus on business logic, error handling, and user-facing functionality.
